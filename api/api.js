// API calls for projects and worklogs

async function loadProjects() {
  const worklogContainer = document.getElementById("worklogContainer");

  try {
    // Use the selected start date to fetch projects
    const dateToUse =
      window.selectedStartDate || new Date().toISOString().split("T")[0];
    const response = await fetch(
      `https://sra-api.smartosc.com/api/projects/all?userId=${AppState.currentUserId}&date=${dateToUse}`,
      {
        headers: {
          accept: "application/json, text/plain, */*",
          authorization: `Bearer ${AppState.currentToken}`,
        },
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `HTTP ${response.status}: ${errorText || response.statusText}`
      );
    }

    // Check if response has content before parsing JSON
    const responseText = await response.text();
    if (!responseText || responseText.trim() === "") {
      throw new Error("Empty response received from server");
    }

    AppState.projectsList = JSON.parse(responseText);

    // If no projects are returned, add the default "Other" project with ID 0
    if (!AppState.projectsList || AppState.projectsList.length === 0) {
      AppState.projectsList = [
        {
          id: 0,
          name: "Other",
          code: "OTHER",
        },
      ];
    }

    await renderWorklogForm();
  } catch (error) {
    await showProjectLoadError(error.message, true);
  }
}

async function loadProjectsForAutoFlow() {
  const worklogContainer = document.getElementById("worklogContainer");

  try {
    // Ensure we have username
    if (!AppState.currentUsername) {
      // Try to get from storage or fetch again
      const stored = await chrome.storage.local.get(["smo_username"]);
      if (stored.smo_username) {
        AppState.currentUsername = stored.smo_username;
      } else {
        // Fetch user info again to get username
        const response = await fetch(
          "https://sra-api.smartosc.com/api/users/current-user",
          {
            headers: {
              accept: "application/json, text/plain, */*",
              authorization: `Bearer ${AppState.currentToken}`,
            },
          }
        );
        if (response.ok) {
          const userData = await response.json();
          AppState.currentUsername = userData.username || userData.userName || null;
          if (AppState.currentUsername) {
            await chrome.storage.local.set({ smo_username: AppState.currentUsername });
          }
        }
      }
    }

    if (!AppState.currentUsername) {
      throw new Error("Unable to retrieve username. Please try again.");
    }

    // Use the selected date range
    const startDate = window.selectedStartDate;
    const endDate = window.selectedEndDate;

    // Call timesheet-overview API
    const response = await fetch(
      `https://sra-api.smartosc.com/api/timesheet-overview?username=${AppState.currentUsername}&startDate=${startDate}&endDate=${endDate}`,
      {
        headers: {
          accept: "application/json, text/plain, */*",
          authorization: `Bearer ${AppState.currentToken}`,
        },
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `HTTP ${response.status}: ${errorText || response.statusText}`
      );
    }

    // Check if response has content before parsing JSON
    const responseText = await response.text();
    if (!responseText || responseText.trim() === "") {
      throw new Error("Empty response received from server");
    }

    const data = JSON.parse(responseText);
    const timesheetOverview = data.timesheetOverview || [];

    // Generate worklog entries based on allocated data
    AppState.autoGeneratedWorklogs = generateWorklogsFromAllocated(timesheetOverview);

    if (AppState.autoGeneratedWorklogs.length === 0) {
      worklogContainer.innerHTML = `
        <div style="padding: 20px; text-align: center;">
          <p style="color: rgba(255, 255, 255, 0.9); text-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);">
            No worklog entries to generate. All allocated hours are already logged.
          </p>
          <button class="info" onclick="location.reload()" style="margin-top: 15px;">Go Back</button>
        </div>
      `;
      return;
    }

    // Fetch project IDs by calling projects API for each unique project code
    const projectCodeToIdMap = new Map();

    // Fetch projects for the start date to get project IDs
    const dateToUse = window.selectedStartDate;
    try {
      const projectsResponse = await fetch(
        `https://sra-api.smartosc.com/api/projects/all?userId=${AppState.currentUserId}&date=${dateToUse}`,
        {
          headers: {
            accept: "application/json, text/plain, */*",
            authorization: `Bearer ${AppState.currentToken}`,
          },
        }
      );

      if (projectsResponse.ok) {
        const projectsText = await projectsResponse.text();
        if (projectsText && projectsText.trim() !== "") {
          const projectsData = JSON.parse(projectsText);
          projectsData.forEach(project => {
            projectCodeToIdMap.set(project.code, project.id);
          });
        }
      }
    } catch (error) {
      console.warn("Failed to fetch project IDs:", error);
    }

    // Update worklogs with project IDs
    AppState.autoGeneratedWorklogs.forEach(wl => {
      wl.projectId = projectCodeToIdMap.get(wl.projectCode) || 0; // Use 0 (Other) if not found
    });

    // Get unique projects from generated worklogs
    const projectMap = new Map();
    AppState.autoGeneratedWorklogs.forEach(wl => {
      const key = wl.projectId || 0;
      if (!projectMap.has(key)) {
        projectMap.set(key, {
          id: wl.projectId || 0,
          name: wl.projectName,
          code: wl.projectCode,
        });
      }
    });

    AppState.projectsList = Array.from(projectMap.values());

    // If no projects, add default "Other"
    if (AppState.projectsList.length === 0) {
      AppState.projectsList = [
        {
          id: 0,
          name: "Other",
          code: "OTHER",
        },
      ];
    }

    // Render auto flow worklog form
    await renderAutoWorklogForm();
  } catch (error) {
    await showProjectLoadError(error.message, true);
  }
}

async function submitWorklog() {
  const submitBtn = document.getElementById("submitBtn");

  // Check if this is auto flow (has auto worklog checkboxes)
  const autoCheckboxes = document.querySelectorAll(".auto-worklog-checkbox");
  let workLogs = [];

  if (autoCheckboxes.length > 0) {
    // Auto flow: use auto-generated worklogs
    const checkedEntries = Array.from(autoCheckboxes).filter(cb => cb.checked);

    if (checkedEntries.length === 0) {
      alert("No worklog entries selected! Please check at least one entry.");
      return;
    }

    try {
      workLogs = checkedEntries.map(checkbox => {
        const index = parseInt(checkbox.dataset.index);
        const worklog = AppState.autoGeneratedWorklogs[index];
        const hourInput = document.querySelector(`.auto-worklog-hours[data-index="${index}"]`);
        const hours = parseFloat(hourInput.value) || worklog.hours;

        if (hours <= 0 || hours > 24) {
          throw new Error(`Invalid hours for ${worklog.date}: ${hours}. Hours must be between 0.5 and 24.`);
        }

        return {
          date: worklog.date,
          description: null,
          workHours: hours,
          typeOfWork: worklog.typeOfWork || 6,
          projectId: worklog.projectId || 0,
        };
      });
    } catch (error) {
      alert(error.message);
      return;
    }
  } else {
    // Manual flow: use existing logic
    const workHoursInput = document.getElementById("workHours");

    if (!AppState.selectedProject) {
      alert("Please select a project");
      return;
    }

    const workHours = parseFloat(workHoursInput.value) || 8;

    if (workHours <= 0 || workHours > 24) {
      alert("Work hours must be between 0.5 and 24 hours");
      return;
    }

    const startDate = new Date(window.selectedStartDate);
    const endDate = new Date(window.selectedEndDate);
    const weekdays = getWeekdaysBetween(startDate, endDate);

    // Get all leave days (unchecked checkboxes)
    const checkboxes = document.querySelectorAll(".leave-checkbox");
    const leaveDates = new Set(
      Array.from(checkboxes)
        .filter((cb) => !cb.checked)
        .map((cb) => cb.dataset.date)
    );

    // Filter out leave days from weekdays
    const workingDays = weekdays.filter((date) => {
      const dateStr = date.toISOString().split("T")[0];
      return !leaveDates.has(dateStr);
    });

    // Check if there are any working days
    if (workingDays.length === 0) {
      alert(
        "No working days selected! Please check at least one day or select a different date range."
      );
      return;
    }

    // Generate workLogs payload only for working days
    workLogs = workingDays.map((date) => ({
      date: date.toISOString().split("T")[0],
      description: null,
      workHours: workHours,
      typeOfWork: 6,
      projectId: AppState.selectedProject.id,
    }));
  }

  const payload = { workLogs };

  // Disable button and show loading
  submitBtn.disabled = true;
  submitBtn.innerHTML = "Submitting...";

  try {
    const response = await fetch(
      "https://sra-api.smartosc.com/api/user/worklogs",
      {
        method: "POST",
        headers: {
          accept: "application/json, text/plain, */*",
          authorization: `Bearer ${AppState.currentToken}`,
          "content-type": "application/json",
        },
        body: JSON.stringify(payload),
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Failed to submit worklog: ${response.status} - ${errorText}`
      );
    }

    // Check if response has content before parsing JSON
    const responseText = await response.text();
    let result;

    if (responseText && responseText.trim() !== "") {
      try {
        result = JSON.parse(responseText);
      } catch (parseError) {
        // If JSON parsing fails, use the text response
        result = { message: "Success", response: responseText };
      }
    } else {
      // Empty response means success (204 No Content or similar)
      result = { message: "Worklog submitted successfully" };
    }

    // Show success message
    let totalHours, workingDaysCount, projectName, leaveDaysMessage;

    if (autoCheckboxes.length > 0) {
      // Auto flow success message
      totalHours = workLogs.reduce((sum, wl) => sum + wl.workHours, 0);
      workingDaysCount = workLogs.length;
      const uniqueProjects = new Set(workLogs.map(wl => wl.projectId));
      projectName = uniqueProjects.size === 1
        ? (AppState.projectsList.find(p => p.id === workLogs[0].projectId)?.name || "Multiple Projects")
        : `${uniqueProjects.size} projects`;
      leaveDaysMessage = "";
    } else {
      // Manual flow success message
      // Recalculate weekdays and workingDays for success message
      const startDate = new Date(window.selectedStartDate);
      const endDate = new Date(window.selectedEndDate);
      const weekdays = getWeekdaysBetween(startDate, endDate);
      const checkboxes = document.querySelectorAll(".leave-checkbox");
      const leaveDates = new Set(
        Array.from(checkboxes)
          .filter((cb) => !cb.checked)
          .map((cb) => cb.dataset.date)
      );
      const workingDays = weekdays.filter((date) => {
        const dateStr = date.toISOString().split("T")[0];
        return !leaveDates.has(dateStr);
      });
      const workHours = parseFloat(document.getElementById("workHours").value) || 8;
      
      totalHours = workingDays.length * workHours;
      workingDaysCount = workingDays.length;
      const leaveDaysCount = weekdays.length - workingDays.length;
      projectName = AppState.selectedProject ? AppState.selectedProject.name : "Unknown Project";
      leaveDaysMessage = leaveDaysCount > 0
        ? `<p style="color: rgba(255, 255, 255, 0.95); background: rgba(255, 243, 205, 0.3); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 8px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2); text-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);">Skipped ${leaveDaysCount} day(s) marked as leave</p>`
        : "";
    }

    // Extract success message from result
    const successMessage = result.message || "Worklog submitted successfully";

    const html = await loadTemplate("worklog-success", {
      SUCCESS_MESSAGE: successMessage,
    });

    // Replace entire container content with success message
    const worklogContainer = document.getElementById("worklogContainer");
    if (worklogContainer) {
      worklogContainer.innerHTML = html;
      
      // Add event listener for close button
      const closeBtn = document.getElementById("closeSuccessBtn");
      if (closeBtn) {
        closeBtn.addEventListener("click", () => {
          location.reload();
        });
      }
    } else {
      // Fallback: show alert
      alert(successMessage);
    }
  } catch (error) {
    alert(`Error: ${error.message}`);
    submitBtn.innerHTML = "Submit Worklog";
    submitBtn.disabled = false;
  }
}

